# AI Interview Application - Data Contracts

This document defines the data contracts for the AI Interview Application, based on the revised Technical Design Document (`ai_interview_tdd_v1`).

## 1. Common Data Structures (Go)

These structs are used across multiple API endpoints and WebSocket messages.

```go
package contracts

import "time"

// Role defines the possible roles of a participant in an interview.
type Role string

const (
    RoleCandidate   Role = "candidate"
    RoleInterviewer Role = "interviewer"
    RoleAI          Role = "ai"
)

// SessionStatus defines the possible states of an interview session.
type SessionStatus string

const (
    StatusScheduled  SessionStatus = "scheduled"
    StatusInProgress SessionStatus = "in_progress"
    StatusCompleted  SessionStatus = "completed"
    StatusCancelled  SessionStatus = "cancelled"
)

// ParticipantStatus defines the connection status of a participant.
type ParticipantStatus string

const (
    StatusJoining      ParticipantStatus = "joining"
    StatusConnected    ParticipantStatus = "connected"
    StatusDisconnected ParticipantStatus = "disconnected"
    StatusFailed       ParticipantStatus = "failed"
)

// InteractionType defines the type of a conversation interaction.
type InteractionType string

const (
    InteractionQuestion InteractionType = "question"
    InteractionAnswer   InteractionType = "answer"
    InteractionComment  InteractionType = "comment"
    InteractionSystem   InteractionType = "system_message" // For system-generated messages
)

// AIStatus defines the possible states of the AI agent.
type AIStatus string

const (
    AIStatusIdle       AIStatus = "idle"
    AIStatusListening  AIStatus = "listening"  // AI is actively listening (e.g., processing STT)
    AIStatusProcessing AIStatus = "processing" // AI is thinking (e.g., calling Gemini)
    AIStatusSpeaking   AIStatus = "speaking"   // AI is generating/sending response (TTS/Text)
    AIStatusError      AIStatus = "error"      // AI encountered an error
)


// ParticipantInfo represents basic information about a participant.
type ParticipantInfo struct {
    ParticipantID string            `json:"participantId"` // Unique ID within the session
    UserID        string            `json:"userId"`        // Global User ID
    Role          Role              `json:"role"`
    Name          string            `json:"name"`          // User's display name (fetched via UserID)
    Status        ParticipantStatus `json:"status"`
}

// InteractionInfo represents a single interaction in the conversation history.
type InteractionInfo struct {
    InteractionID        string          `json:"interactionId"`
    Timestamp            time.Time       `json:"timestamp"`
    SpeakerParticipantID string          `json:"speakerParticipantId"`
    SpeakerUserID        string          `json:"speakerUserId"` // Denormalized for convenience
    SpeakerRole          Role            `json:"speakerRole"`   // Denormalized for convenience
    Type                 InteractionType `json:"type"`
    Content              string          `json:"content"` // Text content
    AudioReference       *string         `json:"audioReference,omitempty"` // Optional URL/path to audio
}

// ErrorResponse is a standard structure for API error responses.
type ErrorResponse struct {
	Error   string `json:"error"`
	Details string `json:"details,omitempty"`
}

````

## 2. REST API Contracts

These define the request and response bodies for the REST endpoints managed by the API Gateway, primarily routing to the Interview and AI services. All endpoints require `Authorization: Bearer <jwt_token>` header unless otherwise specified.

### 2.1 Interview Service API (`/api/interview/*`)

**`a) POST /api/interview - Create Interview Session`**

- **Description:** Creates a new interview session. Typically called by an administrator or scheduling system.
    
- **Request Body:**
    
    ```
    type CreateInterviewRequest struct {
        ScheduledTime   time.Time       `json:"scheduledTime"`
        JobDescription  string          `json:"jobDescription"`
        ParticipantPermissions map[string]Role `json:"participantPermissions"` // Map UserID -> Role
    }
    ```
    
- **Response Body (201 Created):**
    
    ```
    type CreateInterviewResponse struct {
        SessionID     string        `json:"sessionId"`
        Status        SessionStatus `json:"status"` // Will be 'Scheduled'
        ScheduledTime time.Time     `json:"scheduledTime"`
    }
    ```
    
- **Error Responses:** 400 (Bad Request), 401 (Unauthorized), 500 (Internal Server Error)
    

**`b) GET /api/interview/{sessionId} - Get Interview Session Details`**

- **Description:** Retrieves details for a specific interview session. User must have permission.
    
- **Path Parameter:** `sessionId` (string)
    
- **Request Body:** None
    
- **Response Body (200 OK):**
    
    ```
    type GetInterviewResponse struct {
        SessionID           string             `json:"sessionId"`
        Status              SessionStatus      `json:"status"`
        ScheduledTime       time.Time          `json:"scheduledTime"`
        JobDescription      string             `json:"jobDescription"`
        Participants        []ParticipantInfo  `json:"participants"` // Current participants in the session
        ConversationHistory []InteractionInfo  `json:"conversationHistory"`
    }
    ```
    
- **Error Responses:** 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 500 (Internal Server Error)
    

**`c) POST /api/interview/{sessionId}/join - Authorize Join & Get Signaling Info`**

- **Description:** Authenticated user requests to join a session. Returns necessary info to connect to Signaling Service and SFU.
    
- **Path Parameter:** `sessionId` (string)
    
- **Request Body:** None (UserID is derived from JWT token)
    
- **Response Body (200 OK):**
    
    ```
    type JoinInterviewResponse struct {
        SignalingToken string `json:"signalingToken"` // Short-lived token for WebSocket auth
        WebSocketURL   string `json:"webSocketUrl"`   // URL for Signaling Service
        // SFU connection details might be included here or fetched via WebSocket later
        SfuInfo        interface{} `json:"sfuInfo,omitempty"` // Placeholder for SFU details if provided directly
    }
    ```
    
- **Error Responses:** 401 (Unauthorized), 403 (Forbidden - User not permitted), 404 (Not Found - Session doesn't exist), 409 (Conflict - Session not in joinable state), 500 (Internal Server Error)
    

**`d) POST /api/interview/{sessionId}/interaction - Record Interaction`**

- **Description:** Used internally (e.g., by AI Service) to record a new interaction in the session history.
    
- **Path Parameter:** `sessionId` (string)
    
- **Request Body:**
    
    ```
    type RecordInteractionRequest struct {
        SpeakerParticipantID string          `json:"speakerParticipantId"`
        SpeakerUserID        string          `json:"speakerUserId"`
        SpeakerRole          Role            `json:"speakerRole"`
        Type                 InteractionType `json:"type"`
        Content              string          `json:"content"`
        AudioReference       *string         `json:"audioReference,omitempty"`
    }
    ```
    
- **Response Body (201 Created):**
    
    ```
    type RecordInteractionResponse struct {
        InteractionID string `json:"interactionId"`
    }
    ```
    
- **Error Responses:** 400 (Bad Request), 404 (Not Found), 500 (Internal Server Error)
    

**`e) GET /api/interview/{sessionId}/context - Get AI Context`**

- **Description:** Used internally by AI Service to get necessary context for generating questions.
    
- **Path Parameter:** `sessionId` (string)
    
- **Request Body:** None
    
- **Response Body (200 OK):**
    
    ```
    type GetAIContextResponse struct {
        JobDescription      string            `json:"jobDescription"`
        ConversationHistory []InteractionInfo `json:"conversationHistory"` // Potentially limited to recent history
        // Other relevant context TBD
    }
    ```
    
- **Error Responses:** 404 (Not Found), 500 (Internal Server Error)
    

_`` `(Note: Endpoints for updating participant status (UpdateParticipantStatus) and leaving (Leave) are typically handled via the Signaling Service interactions and internal API calls, not directly exposed to the frontend user)` ``_

### 2.2 AI Service API (`/api/ai/*`)

**`a) POST /api/ai/{sessionId}/process_response - Process Candidate Response`**

- **Description:** Frontend sends the final transcript of a candidate's response to the AI service.
    
- **Path Parameter:** `sessionId` (string)
    
- **Request Body:**
    
    ```
    type ProcessResponseRequest struct {
        Transcript string `json:"transcript"`
        UserID     string `json:"userId"` // UserID of the speaker (Candidate)
    }
    ```
    
- **Response Body (202 Accepted):**
    
    ```
    // Empty body indicates the request was accepted for processing.
    // AI will communicate its next steps (asking question, etc.) via WebSocket messages.
    ```
    
- **Error Responses:** 400 (Bad Request), 401 (Unauthorized), 404 (Not Found - Session invalid), 500 (Internal Server Error)
    

## 3. WebSocket Message Contracts (Signaling Service - `/ws/signal`)

Messages exchanged over the WebSocket connection established after calling `/join`. All messages should ideally be wrapped in a standard structure.

```
package contracts

import "encoding/json"

// Generic WebSocket message structure
type WebSocketMessage struct {
	Type    string          `json:"type"` // Defines the message type (e.g., "offer", "ai_status")
	Payload json.RawMessage `json:"payload"` // The actual data, specific to the type
}

// Helper function to create a WebSocketMessage
func NewWebSocketMessage(msgType string, payload interface{}) ([]byte, error) {
	payloadBytes, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}
	msg := WebSocketMessage{
		Type:    msgType,
		Payload: payloadBytes,
	}
	return json.Marshal(msg)
}

// Helper function to unmarshal payload
func UnmarshalPayload(msg WebSocketMessage, v interface{}) error {
	return json.Unmarshal(msg.Payload, v)
}

// --- Client-to-Server Message Payloads ---

type RequestMediaConfigPayload struct {
	UserID string `json:"userId"` // Redundant? UserID known from connection context
} // Type: "request_media_config"

type SdpPayload struct {
	Target string `json:"target"` // "sfu" or potentially a specific participant ID for P2P data
	Sdp    string `json:"sdp"`
} // Type: "offer", "answer"

type IceCandidatePayload struct {
	Target    string      `json:"target"` // "sfu" or participant ID
	Candidate interface{} `json:"candidate"` // The ICE candidate object
} // Type: "ice_candidate"

type ConnectionEstablishedPayload struct {
	// Potentially empty, just signals completion
} // Type: "connection_established"

type SpeakingStatusPayload struct {
	UserID   string `json:"userId"` // User sending the status
	Speaking bool   `json:"speaking"`
} // Type: "speaking_status"

type LeaveRequestPayload struct {
	UserID string `json:"userId"` // User requesting to leave
} // Type: "leave_request"


// --- Server-to-Client Message Payloads ---

type MediaConfigPayload struct {
	SfuDetails interface{} `json:"sfuDetails"` // SFU-specific connection info (URL, credentials, etc.)
} // Type: "media_config"

// SdpPayload (Type: "offer", "answer") - Same as Client->Server
// IceCandidatePayload (Type: "ice_candidate") - Same as Client->Server

type SessionReadyPayload struct {
	Participants []ParticipantInfo `json:"participants"` // List of all participants currently in the session
} // Type: "session_ready"

type ParticipantJoinedPayload struct {
	Participant ParticipantInfo `json:"participant"` // Details of the participant who joined
} // Type: "participant_joined"

type ParticipantLeftPayload struct {
	UserID string `json:"userId"` // UserID of the participant who left
} // Type: "participant_left"

type ParticipantSpeakingPayload struct {
	UserID   string `json:"userId"`
	Speaking bool   `json:"speaking"`
} // Type: "participant_speaking"

type AIStatusPayload struct {
	SessionID string   `json:"sessionId"` // Context
	Status    AIStatus `json:"status"`
} // Type: "ai_status"

type AIMessagePayload struct {
	SessionID      string  `json:"sessionId"` // Context
	Text           string  `json:"text"`      // The AI's message/question text
	AudioReference *string `json:"audioReference,omitempty"` // Optional URL/path to audio
} // Type: "ai_message"

type SystemMessagePayload struct {
	SessionID string `json:"sessionId"` // Context
	Text      string `json:"text"`      // System message content (e.g., "AI encountered an error")
	Level     string `json:"level"`     // Optional: "info", "warning", "error"
} // Type: "system_message"

type LeaveAckPayload struct {
	// Empty, just acknowledges the leave request
} // Type: "leave_ack"

```

## 4. Database Schema (PostgreSQL)

```
-- Represents registered users (can be expanded significantly)
CREATE TABLE users (
    user_id VARCHAR(255) PRIMARY KEY, -- Using VARCHAR for UUIDs or external IDs
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
    -- Add password hash, etc. if managing auth here
);

-- Main table for interview sessions
CREATE TABLE interview_sessions (
    session_id VARCHAR(255) PRIMARY KEY, -- Using VARCHAR for UUIDs
    status VARCHAR(50) NOT NULL DEFAULT 'scheduled', -- scheduled, in_progress, completed, cancelled
    scheduled_time TIMESTAMPTZ,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    job_description TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Stores which users are permitted to join which session and their role
CREATE TABLE access_permissions (
    permission_id SERIAL PRIMARY KEY, -- Or use composite key (session_id, user_id)
    session_id VARCHAR(255) NOT NULL REFERENCES interview_sessions(session_id) ON DELETE CASCADE,
    user_id VARCHAR(255) NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL, -- candidate, interviewer, ai
    UNIQUE (session_id, user_id) -- Ensure user has only one role per session
);

-- Tracks participants currently or previously connected to a session
-- This might be partly managed in memory by Signaling/Interview service during the call,
-- but persisted for logging/auditing or if long-lived participant state is needed.
-- Alternatively, this could be merged more tightly with access_permissions if connection state isn't persisted long-term.
CREATE TABLE participants (
    participant_id VARCHAR(255) PRIMARY KEY, -- Unique ID for this participant instance in this session
    session_id VARCHAR(255) NOT NULL REFERENCES interview_sessions(session_id) ON DELETE CASCADE,
    user_id VARCHAR(255) NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- User must exist
    role VARCHAR(50) NOT NULL, -- Denormalized from access_permissions for easier access during session
    status VARCHAR(50) NOT NULL DEFAULT 'joining', -- joining, connected, disconnected, failed
    joined_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMPTZ,
    signaling_id VARCHAR(255) -- Optional: Store associated WebSocket connection ID while connected
);

-- Stores the conversation history
CREATE TABLE interactions (
    interaction_id VARCHAR(255) PRIMARY KEY, -- Using VARCHAR for UUIDs
    session_id VARCHAR(255) NOT NULL REFERENCES interview_sessions(session_id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    speaker_participant_id VARCHAR(255) REFERENCES participants(participant_id) ON DELETE SET NULL, -- Link to participant instance
    speaker_user_id VARCHAR(255) NOT NULL, -- Denormalized UserID
    speaker_role VARCHAR(50) NOT NULL, -- Denormalized Role
    interaction_type VARCHAR(50) NOT NULL, -- question, answer, comment, system_message
    content TEXT NOT NULL,
    audio_reference VARCHAR(1024) -- Optional: URL or path to stored audio file
);

-- Indexes for common lookups
CREATE INDEX idx_access_permissions_session ON access_permissions(session_id);
CREATE INDEX idx_access_permissions_user ON access_permissions(user_id);
CREATE INDEX idx_participants_session ON participants(session_id);
CREATE INDEX idx_participants_user ON participants(user_id);
CREATE INDEX idx_interactions_session ON interactions(session_id);
CREATE INDEX idx_interactions_timestamp ON interactions(timestamp);

-- Optional: Table for AI Conversation State (if persistence needed beyond service memory)
CREATE TABLE ai_conversations (
    session_id VARCHAR(255) PRIMARY KEY REFERENCES interview_sessions(session_id) ON DELETE CASCADE,
    current_state VARCHAR(50) NOT NULL DEFAULT 'idle', -- idle, listening, processing, speaking,
```